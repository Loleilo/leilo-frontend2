model 1
{
	poll_calls: {
		call_string: {
			state: "fetching/fetched/error",
			poll_interval: 4322,
			retCode: return code of thing,
			retData: return data of call,
			updatePath: pointer to object to update
		}
	}
}
call_string is just stringified json of call - generated by dispatch

when fetch, another action is dispatched, telling entities to update

model 2
{
	polling:{ // not sure if this is good practice
		call_string: {
			state: "fetching/fetched/error",
			poll_interval: 4322,
			retCode: return code of thing,
			retData: return data of call,
			updatePath: pointer to object to update
		}
	},
	
	entities:{
		user:{
			loginState: LOGGED_IN,
			userGroupsPerms:{
				"groupid":{
					state: LOADED,
					value: 5,
				}
			}
		},
		
		groups:{
			groupUsers:{
				"groupuuid":{
					state: LOADED,
					value: ["uuid of user", ...]
				}
			},
			groupsList:{
				state: WRITING,
				value:[uuid, ...],
			},	
			groupAtomPerms: {
				"groupuuid":{
					"atomuuid":{
						state: WRITING,
						value: 5,
					}
				}
			}
		},
		
		atoms:{
			atomGroups:{
				"atomuuid":{
					state: LOADED,
					value: ["uuid of group", ...]
				}
			},
			atomValues:{
				"atomuuid":{
					state: WRITING,
					value:"value of atom" //remember to json sanitize
				}
			}
		},
	}
}

an object can uploaded/fetched to server only when it has a state variable
UNLOADED, 
OAD_ERROR - unable to load, 
LOADING - currently getting from server, 
WRITING - currently writing to server, 
POLLING - waiting for next fetch, 
LOADED - loaded but not polling

polled by pollercomponent
 - will traverse object and 

//each action just corresponds to api

reducers:
 - group
    -
 - atom
 - user
 
