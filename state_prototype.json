model 1
{
	poll_calls: {
		call_string: {
			state: "fetching/fetched/error",
			poll_interval: 4322,
			retCode: return code of thing,
			retData: return data of call,
			updatePath: pointer to object to update
		}
	}
}
call_string is just stringified json of call - generated by dispatch

when fetch, another action is dispatched, telling entities to update

model 2
{
	polling:{ // not sure if this is good practice
		call_string: {
			state: "fetching/fetched/error",
			poll_interval: 4322,
			retCode: return code of thing,
			retData: return data of call,
			updatePath: pointer to object to update
		}
	},
	
	entities:{
		user:{
			loginState: LOGGED_IN,
			userGroupsPerms:{
				"groupid":{
					state: LOADED,
					value: 5,
				}
			}
			groupsList:{
				state: WRITING,
				value:[uuid, ...],
			},	
		},
		
		groups:{
			groupUsers:{
				"groupuuid":{
					state: LOADED,
					value: ["uuid of user", ...]
				}
			},
			groupAtomsList:{
				"groupuuid":{
					state: LOADED,
					value: ["uuid of atom", ...]
				}
			}
		},
		
		atoms:{
			atomNames:{
				"groupuuid":{
					"atomuuid":{
						state: LOADED,
						value: "name"
					}
				}
			}
			
			atomGroups:{
				"groupuuid":{
					"atomuuid":{
						state: LOADED,
						value: ["uuid of group", ...]
					}
				}
			},
			
			atomValues:{
				"groupuuid":{
					"atomuuid":{
						state: WRITING,
						value:"value of atom" //remember to json sanitize
					}
				}
			},
			
			groupAtomPerms: {
				"groupuuid":{
					"atomuuid":{
						state: WRITING,
						value: 5,
					}
				}
			}
		},
	}
	
	errors:[
	]
}

polled by pollercomponent
 - will traverse polling list and refetch things

//each action just corresponds to api

reducers:
 - group
    -
 - atom
 - user
 
